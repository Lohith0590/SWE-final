/**
 * Dependency imports
 */
import { useRef, useEffect, useState } from 'react';
import { getType, mergeObjects } from 'noyb';
/**
 * useAsync
 */

export default (function (generatorFunction, initialState) {
  var state = useRef(initialState);
  var argsRef = useRef([]);
  var iterator = useRef();
  var hasError = useRef(false);
  var promiseResolve = useRef();
  var promiseReject = useRef();
  var nextValue = useRef();

  var _useState = useState(),
      nextResult = _useState[0],
      setNextResult = _useState[1];

  var iterate = function iterate() {
    if (iterator.current === undefined) {
      iterator.current = generatorFunction.apply(void 0, arguments);
    }

    var next = iterator.current.next(nextValue.current);

    var checkForNextResult = function checkForNextResult() {
      if (!next.done) {
        setNextResult(next);
      } else {
        if (hasError.current !== false && promiseReject.current) {
          promiseReject.current(hasError.current);
        } else if (promiseResolve.current) {
          promiseResolve.current(state.current);
        }

        iterator.current = undefined;
      }
    };

    if (next.value instanceof Promise) {
      next.value.then(function (resolvedValue) {
        nextValue.current = resolvedValue;
      })["catch"](function (err) {
        nextValue.current = err;
        hasError.current = err;
      })["finally"](checkForNextResult);
    } else {
      if (getType(state.current) === 'object') {
        var _next$value;

        state.current = mergeObjects(state.current, (_next$value = next.value) != null ? _next$value : {});
      } else {
        state.current = next.value;
      }

      checkForNextResult();
    }
  };

  var cancel = function cancel() {
    if (iterator.current) iterator.current["return"]();
  };

  var execute = function execute() {
    cancel();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    argsRef.current = args;
    return new Promise(function (resolve, reject) {
      promiseResolve.current = resolve;
      promiseReject.current = reject;
      iterate.apply(void 0, argsRef.current);
    });
  };

  useEffect(function () {
    if (nextResult) iterate.apply(void 0, argsRef.current);
  }, [nextResult]);
  return [state.current, execute, cancel];
});