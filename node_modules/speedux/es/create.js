import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * Dependency imports
 */
import { getType, mergeObjects } from 'noyb';
/**
 * Local imports
 */

import store from './store';
import useDispatch from './use-dispatch';
import useGlobalState from './use-global-state';
import _useActions from './use-actions';
import lookbook from './lookbook';
import * as helpers from './helpers';
/**
 * Error messages map
 */

export var ERRORS = {
  MISSING_CONFIG: 'Configuration object is required.',
  INVALID_CONFIG: 'Configuration must be a valid object.',
  MISSING_NAME: 'Missing required field `name` for the global state.',
  INVALID_NAME: 'Name must be a string.'
};
export var createReducer = function createReducer(name, initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var reducer = function reducer(prevState, action) {
    var state = prevState != null ? prevState : initialState;
    var actionParts = []; // [actionPrefix, mainAction, subAction]

    if (action.subtype) {
      if (/@@(.+?)\/(.+)/.test(action.type)) {
        var actionSuffix = action.type.replace(/^.*?(\/|$)/, '');
        actionParts[0] = action.type.replace(/^@@|\/.*?$/g, '');

        var _actionSuffix$split = actionSuffix.split('/');

        actionParts[1] = _actionSuffix$split[0];
        actionParts[2] = _actionSuffix$split[1];
      } else {
        var _action$type$split = action.type.split('/');

        actionParts[1] = _action$type$split[0];
        actionParts[2] = _action$type$split[1];
      }

      if (actionParts[2] !== 'UPDATE') {
        return state;
      }
    } else if (/@@(.+?)\/(.+)/.test(action.type)) {
      actionParts[0] = action.type.replace(/^@@|\/.*?$/g, '');
      actionParts[1] = action.type.replace(/^.*?(\/|$)/, '');
    } else {
      var _action$type$split2 = action.type.split('/');

      actionParts[1] = _action$type$split2[0];
      actionParts[2] = _action$type$split2[1];
    }

    var callback = lookbook.actions[name][helpers.toCamelCase(actionParts[1])];
    var callbackType = callback ? 'action' : false;

    if (!callback) {
      var _handlers$actionParts;

      var handlers = lookbook.handlers[name];
      callback = (_handlers$actionParts = handlers[actionParts[1]]) != null ? _handlers$actionParts : handlers[actionParts[0] + "." + helpers.toCamelCase(actionParts[1])];
      callbackType = callback ? 'handler' : false;
    }

    if (callback) {
      var callbackArgs = {
        action: action.args,
        handler: [action]
      }[callbackType];
      var callbackResult = action.subtype ? action.value : callback.apply(void 0, callbackArgs);
      var callbackResultType = getType(callbackResult);
      var stateFragment = {};

      if (callbackResult && typeof callbackResult[Symbol.iterator] === 'function' && typeof callbackResult.next === 'function') {
        var dispatchSubAction = function dispatchSubAction(type, value, cb) {
          requestAnimationFrame(function () {
            var dispatch = useDispatch();
            dispatch({
              type: action.type + "/" + type,
              value: value,
              subtype: true
            });
            cb();
          });
        };

        var execute = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {
            var next;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    next = callbackResult.next(data);

                    if (next.value instanceof Promise) {
                      next.value.then(function (resolvedValue) {
                        dispatchSubAction('RESOLVE', resolvedValue, function () {
                          if (!next.done) execute(resolvedValue);
                        });
                      })["catch"](function (err) {
                        dispatchSubAction('ERROR', err.message, function () {
                          if (!next.done) execute(err);
                        });
                      });
                    } else {
                      dispatchSubAction(next.done ? 'COMPLETE' : 'UPDATE', next.value, function () {
                        if (!next.done) execute(next.value);
                      });
                    }

                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function execute(_x) {
            return _ref.apply(this, arguments);
          };
        }();

        execute();
        return state;
      }

      if (callbackResultType === 'object') {
        stateFragment = callbackResult;
      }

      if (callbackResultType === 'function') {
        stateFragment = callbackResult(state);
      }

      return mergeObjects(state, stateFragment);
    }

    return state;
  };

  store.useReducer(name, reducer, initialState);
  store.update();
};
export default (function (config) {
  if (!config) {
    throw new Error(ERRORS.MISSING_CONFIG);
  }

  var name = config.name,
      _config$state = config.state,
      state = _config$state === void 0 ? {} : _config$state,
      _config$actions = config.actions,
      actions = _config$actions === void 0 ? {} : _config$actions,
      _config$handlers = config.handlers,
      handlers = _config$handlers === void 0 ? {} : _config$handlers;

  if (getType(config) !== 'object') {
    throw new Error(ERRORS.INVALID_CONFIG);
  }

  if (!name) {
    throw new Error(ERRORS.MISSING_NAME);
  }

  if (getType(name) !== 'string') {
    throw new Error(ERRORS.INVALID_NAME);
  }

  store.registerName(name);
  lookbook.actions[name] = actions;
  lookbook.handlers[name] = handlers;
  createReducer(name, state);
  return {
    useState: function useState(query) {
      return useGlobalState(query ? name + "." + query : name);
    },
    useActions: function useActions() {
      return _useActions(name);
    }
  };
});