import _extends from "@babel/runtime/helpers/esm/extends";

/**
 * Dependency imports
 */
import { createStore as createReduxStore, applyMiddleware, compose, combineReducers } from 'redux';
import { queryObject } from 'noyb';
/**
 * This is not the actual store object. This is a wrapper object
 * that manages the Redux store instance. Use `store.getInstance()`
 * to get a reference to the Redux store.
 */

var store = {
  /**
   * An object that is used as a map to store references to registered
   * reducers. This object is used by `getRootReducer()` to create the
   * root reducer for the store.
   * @type {Object}
   */
  reducers: {},

  /**
   * List of subscribers listening to dispatched actions
   */
  subscribers: {},

  /**
   * An array of middlewares to use when creating the store.
   * Use exported method `useMiddleware()` to add other middleware
   * functions to this list.
   * @type {Array}
   */
  middlewares: [],

  /**
   * An object that is used to build the initial state tree for the
   * entire app. Each call to `connect()` will add a new key to this
   * object.
   * @type {Object}
   */
  combinedInitialState: {},

  /**
   * Creates a new Redux store instance and updates the reference.
   */
  create: function create() {
    if (this.storeInstance) return this.storeInstance;
    return this.buildInstance();
  },

  /**
   * Builds a Redux store instance.
   */
  buildInstance: function buildInstance() {
    /* eslint-disable */
    var devToolsExtension = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : function (foo) {
      return foo;
    };
    /* eslint-enable */

    this.devTools = this.devTools || compose(devToolsExtension);
    this.storeInstance = createReduxStore(this.getRootReducer(), compose.apply(void 0, this.middlewares.concat([this.devTools])));
    return this.storeInstance;
  },

  /**
   * Returns the root reducer function.
   */
  getRootReducer: function getRootReducer() {
    if (this.rootReducer) return this.rootReducer;
    return this.buildRootReducer();
  },

  /**
   * Combines all registered reducers and returns a single reducer
   * function.
   */
  buildRootReducer: function buildRootReducer() {
    var _this = this;

    var reducers = _extends({}, this.reducers);

    if (Object.keys(reducers).length === 0) {
      reducers.$_foo = function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      }; // default reducer

    }

    var combinedReducers = combineReducers(reducers);

    this.rootReducer = function (state, action) {
      if (state === void 0) {
        state = _this.combinedInitialState;
      }

      if (action === void 0) {
        action = null;
      }

      // cache the state
      _this.cachedState = state; // get the new state object

      var newState = combinedReducers(state, action); // update cached state

      _this.cachedState = newState; // notify subscribers

      if (_this.subscribers[action.type]) {
        _this.subscribers[action.type].forEach(function (callback) {
          callback(action);
        });
      } // return the new state


      return newState;
    };

    return this.rootReducer;
  },

  /**
   * Updates the root reducer of the store.
   */
  update: function update() {
    return this.storeInstance.replaceReducer(this.buildRootReducer());
  },

  /**
   * Registers a reducer function.
   * @param  {String}   key             Reducer unique identifier key
   * @param  {Function} reducer         Reducer function
   * @param  {Object}   initialState    Optional initial state for the reducer
   */
  useReducer: function useReducer(name, reducer, initialState) {
    this.reducers[name] = reducer;
    this.combinedInitialState[name] = initialState;
  },

  /**
   * Unregisters all reducer functions.
   */
  resetReducers: function resetReducers() {
    this.reducers = {};
    this.combinedInitialState = {};
  },

  /**
   * Subscribe to an action being dispatched.
   * @param {String} actionType   Type of the action to listen to
   * @param {Function} listener   Function that should be called when the action is dispatched
   */
  subscribe: function subscribe(actionType, listener) {
    var _this$subscribers$act;

    this.subscribers[actionType] = (_this$subscribers$act = this.subscribers[actionType]) != null ? _this$subscribers$act : [];

    if (!this.subscribers[actionType].includes(listener)) {
      this.subscribers[actionType].push(listener);
    }
  },

  /**
   * Unsubscribe from an action being dispatched
   * @param {String} actionType   Type of the action to unsubscribe from
   * @param {Function} listener   Function that was used to subscribe
   */
  unsubscribe: function unsubscribe(actionType, listener) {
    this.subscribers[actionType] = this.subscribers[actionType].filter(function (subscriber) {
      return subscriber !== listener;
    });
  },

  /**
   * Allows registering middleware functions such as Router and other middlewares.
   * @param {Function} middleware Middleware function to use
   */
  useMiddleware: function useMiddleware(middleware) {
    this.middlewares.unshift(applyMiddleware(middleware));
  },

  /**
   * Removes all registered middlewares.
   */
  resetMiddlewares: function resetMiddlewares() {
    this.middlewares = [];
  },

  /**
   * Resets the store and deletes the instance.
   */
  reset: function reset() {
    this.resetReducers();
    this.resetMiddlewares();
    delete this.rootReducer;
    delete this.storeInstance;
    delete this.registeredNames;
    this.cachedState = {};
  },

  /**
   * Returns the complete state object or part of it based on a given query. If the
   * query parameter is a string that uses dot notation, it will return the resolved
   * value of the given key. If the query is an object, it will return an object that
   * has the same structure but contains the resolved values. If the query parameter
   * is not provided, the complete state object will be returned.
   * @param   {String|Object}   query   A query string or a query object that represents
   *                                    part of the state object that needs to be fetched.
   *                                    This parameter is not required.
   */
  getState: function getState(query) {
    return queryObject(query, this.cachedState);
  },

  /**
   * Returns an reference to the Redux store instance.
   */
  getInstance: function getInstance() {
    return this.storeInstance;
  },

  /**
   * Registers a module name. The registered name must be unique for each component.
   * @param {String} name Name to register
   */
  registerName: function registerName(name) {
    if (typeof this.registeredNames === 'undefined') {
      this.registeredNames = {};
    }

    if (this.registeredNames[name] === true) {
      var _console = console,
          warn = _console.warn;
      warn("Duplicate name: " + name + ". This name has already been used, please use a different name.");
    } else {
      store.registeredNames[name] = true;
    }
  }
};
export default store;